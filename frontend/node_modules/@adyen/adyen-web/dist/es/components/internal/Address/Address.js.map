{"version":3,"file":"Address.js","sources":["../../../../../src/components/internal/Address/Address.tsx"],"sourcesContent":["import { Fragment, h } from 'preact';\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'preact/hooks';\nimport Fieldset from '../FormFields/Fieldset';\nimport ReadOnlyAddress from './components/ReadOnlyAddress';\nimport { getAddressValidationRules } from './validate';\nimport { addressFormatters, countrySpecificFormatters } from './validate.formats';\nimport { AddressProps } from './types';\nimport { AddressData } from '../../../types/global-types';\nimport FieldContainer from './components/FieldContainer';\nimport useForm from '../../../utils/useForm';\nimport Specifications from './Specifications';\nimport { ADDRESS_SCHEMA, FALLBACK_VALUE } from './constants';\nimport { getMaxLengthByFieldAndCountry } from '../../../utils/validator-utils';\nimport { useCoreContext } from '../../../core/Context/CoreProvider';\nimport AddressSearch from './components/AddressSearch';\nimport { ComponentMethodsRef } from '../UIElement/types';\nimport './Address.scss';\n\nexport default function Address(props: AddressProps) {\n    const { i18n } = useCoreContext();\n\n    const { label = '', requiredFields, visibility, iOSFocusedField = null, showContextualElement } = props;\n\n    /** An object by which to expose 'public' members to the parent UIElement */\n    const addressRef = useRef<ComponentMethodsRef>({});\n    // Just call once\n    if (!Object.keys(addressRef.current).length) {\n        props.setComponentRef?.(addressRef.current);\n    }\n\n    const specifications = useMemo(() => new Specifications(props.specifications), [props.specifications]);\n\n    const requiredFieldsSchema = specifications.getAddressSchemaForCountryFlat(props.countryCode).filter(field => requiredFields.includes(field));\n\n    const [hasSelectedAddress, setHasSelectedAddress] = useState(false);\n\n    const [useManualAddress, setUseManualAddress] = useState(false);\n\n    const [searchErrorMessage, setSearchErrorMessage] = useState('');\n\n    const showAddressSearch = !!props.onAddressLookup;\n\n    const [ignoreCountryChange, setIgnoreCountryChange] = useState(false);\n\n    const showAddressFields = props.onAddressLookup ? hasSelectedAddress || useManualAddress : true;\n\n    const { data, errors, valid, isValid, handleChangeFor, triggerValidation, setData, mergeData } = useForm<AddressData>({\n        schema: requiredFieldsSchema,\n        defaultData: props.data,\n        // Ensure any passed validation rules are merged with the default ones\n        rules: { ...getAddressValidationRules(specifications), ...props.validationRules },\n        formatters: addressFormatters\n    });\n\n    // In partial address mode, country is not in the form schema but we need it for regionalized labels.\n    // Store the merchant's country config once at mount, then use it if form data doesn't have country.\n    const initialCountryRef = useRef<string | undefined>((props.data as AddressData)?.country);\n    const effectiveCountry = (data.country || initialCountryRef.current)?.toUpperCase();\n    const dataWithCountry = useMemo(() => ({ ...data, country: effectiveCountry }), [data, effectiveCountry]);\n\n    const setSearchData = useCallback(\n        (selectedAddress: AddressData) => {\n            const propsKeysToProcess = ADDRESS_SCHEMA;\n            const newStateData = propsKeysToProcess.reduce((acc: AddressData, propKey) => {\n                // Make sure the data provided by the merchant is always strings\n                const providedValue = selectedAddress[propKey];\n                if (providedValue !== null && providedValue !== undefined) {\n                    // Cast everything to string\n                    acc[propKey] = String(providedValue);\n                }\n                return acc;\n            }, {});\n            mergeData(newStateData);\n            setIgnoreCountryChange(true);\n            triggerValidation();\n            setHasSelectedAddress(true);\n        },\n        [setHasSelectedAddress, triggerValidation, setData]\n    );\n\n    const onManualAddress = useCallback(() => {\n        setUseManualAddress(true);\n    }, []);\n\n    // Expose method expected by (parent) Address.tsx\n    addressRef.current.showValidation = () => {\n        triggerValidation();\n        if (showAddressSearch && !showAddressFields && !isValid) {\n            setSearchErrorMessage(i18n.get('address.errors.incomplete'));\n        } else {\n            setSearchErrorMessage('');\n        }\n    };\n\n    /**\n     * For iOS: iOSFocusedField is the name of the element calling for other elements to be disabled\n     * - so if it is set (meaning we are in iOS *and* an input has been focussed) only enable the field that corresponds to this element\n     */\n    const enabledFields: string[] = requiredFieldsSchema.filter(item => {\n        return !iOSFocusedField ? true : item === iOSFocusedField;\n    });\n\n    /**\n     * Effect that:\n     * - Resets validation for all fields by triggering handleChangeFor(fieldName, 'input')\n     * - Applies validation on postalCode field in case it has any value\n     */\n    useEffect((): void => {\n        // if the country was set via setSearchData we don't want to trigger this\n        if (ignoreCountryChange) {\n            setIgnoreCountryChange(false);\n            return;\n        }\n\n        const stateOrProvince = specifications.countryHasDataset(data.country) ? '' : FALLBACK_VALUE;\n        const newData = { ...data, stateOrProvince };\n\n        requiredFields.forEach(fieldName => {\n            handleChangeFor(fieldName, 'input')(newData[fieldName] ?? '');\n        });\n\n        if (newData.postalCode) {\n            handleChangeFor('postalCode', 'blur')(data.postalCode);\n        }\n    }, [data.country]);\n\n    /**\n     * Set the value of 'stateOrProvince' during the initial render if\n     * property is provided during the creation of the payment method\n     */\n    useEffect((): void => {\n        const stateFieldIsRequired = requiredFields.includes('stateOrProvince');\n        const countryHasStatesDataset = data.country && specifications.countryHasDataset(data.country);\n        const addressShouldHaveState = stateFieldIsRequired && countryHasStatesDataset;\n        const stateOrProvince = data.stateOrProvince || (addressShouldHaveState ? '' : FALLBACK_VALUE);\n\n        handleChangeFor('stateOrProvince', 'input')(stateOrProvince);\n    }, []);\n\n    useEffect((): void => {\n        const optionalFields = specifications.getOptionalFieldsForCountry(data.country);\n        const processedData = ADDRESS_SCHEMA.reduce((acc, cur) => {\n            const isOptional = optionalFields.includes(cur);\n            const isRequired = requiredFields.includes(cur);\n            const newValue = data[cur];\n            const initialValue = props.data[cur];\n            // recover default data values which are not requiredFields, or prefill with 'N/A'\n            const fallbackValue = !isRequired && !newValue && !!initialValue ? initialValue : FALLBACK_VALUE;\n            const value = (isOptional && !newValue) || !isRequired ? fallbackValue : newValue;\n            if (value?.length) acc[cur] = value;\n            return acc;\n        }, {});\n\n        // In partial address mode, ensure country is included in output for regionalized labels/validation.\n        if (!(processedData as AddressData).country && initialCountryRef.current) {\n            (processedData as AddressData).country = initialCountryRef.current;\n        }\n\n        props.onChange({ data: processedData, valid, errors, isValid });\n    }, [data, valid, errors, isValid]);\n\n    if (visibility === 'hidden') return null;\n    if (visibility === 'readOnly') return <ReadOnlyAddress data={data} label={label} />;\n\n    const getComponent = (fieldName: string, { classNameModifiers = [] }) => {\n        if (!requiredFields.includes(fieldName)) return null;\n\n        return (\n            <FieldContainer\n                key={fieldName}\n                allowedCountries={props.allowedCountries}\n                classNameModifiers={[...classNameModifiers, fieldName]}\n                data={dataWithCountry}\n                errors={errors}\n                valid={valid}\n                fieldName={fieldName}\n                onInput={handleChangeFor(fieldName, 'input')}\n                onBlur={handleChangeFor(fieldName, 'blur')}\n                onDropdownChange={handleChangeFor(fieldName, 'blur')}\n                specifications={specifications}\n                maxLength={getMaxLengthByFieldAndCountry(countrySpecificFormatters, fieldName, effectiveCountry, true)}\n                trimOnBlur={true}\n                disabled={!enabledFields.includes(fieldName)}\n                onFieldFocusAnalytics={props.onFieldFocusAnalytics}\n                onFieldBlurAnalytics={props.onFieldBlurAnalytics}\n            />\n        );\n    };\n\n    const getWrapper = group => (\n        <div className=\"adyen-checkout__field-group\">\n            {group.map(([field, size]) => getComponent(field, { classNameModifiers: [`col-${size}`] }))}\n        </div>\n    );\n\n    const addressSchema = specifications.getAddressSchemaForCountry(data.country);\n\n    return (\n        <Fragment>\n            <Fieldset classNameModifiers={[label, 'address']} label={label}>\n                {showAddressSearch && (\n                    <AddressSearch\n                        onAddressLookup={props.onAddressLookup}\n                        onAddressSelected={props.onAddressSelected}\n                        onSelect={setSearchData}\n                        onManualAddress={onManualAddress}\n                        externalErrorMessage={searchErrorMessage}\n                        hideManualButton={showAddressFields}\n                        showContextualElement={showContextualElement}\n                        contextualText={i18n.get('address.search.contextualText')}\n                        addressSearchDebounceMs={props.addressSearchDebounceMs}\n                    />\n                )}\n                {showAddressFields && (\n                    <Fragment>{addressSchema.map(field => (field instanceof Array ? getWrapper(field) : getComponent(field, {})))}</Fragment>\n                )}\n            </Fieldset>\n        </Fragment>\n    );\n}\n\nAddress.defaultProps = {\n    countryCode: null,\n    validationRules: null,\n    data: {},\n    onChange: () => {},\n    visibility: 'editable',\n    requiredFields: ADDRESS_SCHEMA,\n    specifications: {},\n    onFieldFocusAnalytics: () => {},\n    onFieldBlurAnalytics: () => {}\n};\n"],"names":["Address","props","i18n","useCoreContext","label","requiredFields","visibility","iOSFocusedField","showContextualElement","addressRef","useRef","Object","keys","current","length","setComponentRef","specifications","useMemo","Specifications","requiredFieldsSchema","getAddressSchemaForCountryFlat","countryCode","filter","field","includes","hasSelectedAddress","setHasSelectedAddress","useState","useManualAddress","setUseManualAddress","searchErrorMessage","setSearchErrorMessage","showAddressSearch","onAddressLookup","ignoreCountryChange","setIgnoreCountryChange","showAddressFields","data","errors","valid","isValid","handleChangeFor","triggerValidation","setData","mergeData","useForm","schema","defaultData","rules","getAddressValidationRules","validationRules","formatters","addressFormatters","initialCountryRef","country","effectiveCountry","toUpperCase","dataWithCountry","setSearchData","useCallback","selectedAddress","newStateData","ADDRESS_SCHEMA","reduce","acc","propKey","providedValue","String","onManualAddress","showValidation","get","enabledFields","item","useEffect","stateOrProvince","countryHasDataset","FALLBACK_VALUE","newData","forEach","fieldName","postalCode","stateFieldIsRequired","countryHasStatesDataset","addressShouldHaveState","optionalFields","getOptionalFieldsForCountry","processedData","cur","isOptional","isRequired","newValue","initialValue","value","onChange","h","ReadOnlyAddress","getComponent","classNameModifiers","FieldContainer","key","allowedCountries","onInput","onBlur","onDropdownChange","maxLength","getMaxLengthByFieldAndCountry","countrySpecificFormatters","trimOnBlur","disabled","onFieldFocusAnalytics","onFieldBlurAnalytics","addressSchema","getAddressSchemaForCountry","Fragment","Fieldset","AddressSearch","onAddressSelected","onSelect","externalErrorMessage","hideManualButton","contextualText","addressSearchDebounceMs","map","Array","div","className","size","defaultProps"],"mappings":"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"}