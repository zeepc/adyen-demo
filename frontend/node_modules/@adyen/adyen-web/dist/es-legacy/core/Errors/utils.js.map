{"version":3,"file":"utils.js","sources":["../../../../src/core/Errors/utils.ts"],"sourcesContent":["import { ERROR_ACTION_BLUR_SCENARIO, ERROR_ACTION_FOCUS_FIELD, ErrorCodePrefixes, SF_ErrorCodes } from './constants';\nimport { SFError } from '../../components/Card/components/CardInput/types';\nimport { SortErrorsObj, SortedErrorObject, GenericError, SetSRMessagesReturnObject } from './types';\nimport { ValidationRuleResult } from '../../utils/Validator/ValidationRuleResult';\nimport { ErrorMessageObject } from '../../utils/Validator/types';\nimport {\n    ENCRYPTED_CARD_NUMBER,\n    ENCRYPTED_EXPIRY_DATE,\n    ENCRYPTED_EXPIRY_MONTH,\n    ENCRYPTED_EXPIRY_YEAR,\n    ENCRYPTED_PWD_FIELD,\n    ENCRYPTED_SECURITY_CODE\n} from '../../components/internal/SecuredFields/lib/constants';\nimport { AriaConfigObject } from '../../components/internal/SecuredFields/lib/types';\nimport type Language from '../../language';\n\n/**\n * Extract and translate all the errorCodes related to a specific securedField\n * @param i18n\n * @param errorCodeIdentifier - the identifier for which type of errorCodes we need to collect e.g. 'cc-num'\n */\nexport const getTranslatedErrors = (i18n: Language, errorCodeIdentifier: string): Record<SF_ErrorCodes, string> => {\n    const transObj = Object.values(SF_ErrorCodes).reduce((acc, value) => {\n        // Limit to errors related to specific sf\n        if (value.includes(errorCodeIdentifier)) {\n            acc[value] = i18n.get(value);\n        }\n        return acc;\n    }, {}) as Record<SF_ErrorCodes, string>;\n\n    return transObj;\n};\n\n/**\n * Adds a new error property to an object.\n * This error property is an object containing the translated errors, stored by code, that relate to the securedFields\n * @param originalObject - object we want to duplicate and enhance\n * @param i18n - an i18n object to use to get translations\n * @returns a duplicate of the original object with a new property: \"error\" whose value is a object containing the translated errors\n */\nexport const addErrorTranslationsToObject = (originalObj: AriaConfigObject, i18n: Language, fieldType: string): AriaConfigObject => {\n    const nuObj: AriaConfigObject = { ...originalObj };\n\n    const errorCodeIdentifier = fieldTypeToErrorCodeIdentifier(fieldType);\n    nuObj.error = getTranslatedErrors(i18n, errorCodeIdentifier);\n\n    return nuObj;\n};\n\nexport const getErrorMessageFromCode = (errorCode: string, codeMap: Record<string, string>): string => {\n    let errMsg = errorCode;\n    for (const [key, value] of Object.entries(codeMap)) {\n        if (value === errorCode) {\n            errMsg = key;\n            break;\n        }\n    }\n    return errMsg?.toLowerCase().replace(/[_.\\s]/g, '-');\n};\n\n/**\n * errorCodeIdentifiers must match the prefixes to the numbers in ERROR_CODES (Errors/constants.ts)\n * (Which in turn must match the keys in the translations files)\n */\nconst fieldTypeToErrorCodeIdentifier = (fieldType: string): string => {\n    let errorCodeIdentifier;\n    switch (fieldType) {\n        case ENCRYPTED_CARD_NUMBER:\n            errorCodeIdentifier = ErrorCodePrefixes.CC_NUM;\n            break;\n        case ENCRYPTED_EXPIRY_DATE:\n            errorCodeIdentifier = ErrorCodePrefixes.CC_DAT;\n            break;\n        case ENCRYPTED_EXPIRY_MONTH:\n            errorCodeIdentifier = ErrorCodePrefixes.CC_MTH;\n            break;\n        case ENCRYPTED_EXPIRY_YEAR:\n            errorCodeIdentifier = ErrorCodePrefixes.CC_YR;\n            break;\n        case ENCRYPTED_SECURITY_CODE:\n            errorCodeIdentifier = ErrorCodePrefixes.CC_CVC;\n            break;\n        case ENCRYPTED_PWD_FIELD:\n            errorCodeIdentifier = ErrorCodePrefixes.KCP_PWD;\n            break;\n        default:\n    }\n    return errorCodeIdentifier;\n};\n\n/**\n * sortErrorsByLayout - takes a list of errors and a layout, and returns a sorted array of error objects with translated error messages\n *\n * @param errors - an object containing errors, referenced by field type\n * @param layout - a string[] controlling how the output error objects will be ordered. Required when it is known that the way the error object is populated can vary e.g. Card comp, &/or anything with a country selector\n * @param i18n - our internal Language mechanism\n * @param countrySpecificLabels - some errors are region specific, e.g. in the US \"postal code\" = \"zip code\", so map the fieldType value accordingly (if it is being added to the errorMessage string)\n * @param fieldTypeMappingFn - a component specific lookup function that will tell us both if we need to prepend the field type to the SR panel message, and, if so, will retrieve the correct translation for the field type\n */\nexport const sortErrorsByLayout = ({ errors, i18n, layout, countrySpecificLabels, fieldTypeMappingFn }: SortErrorsObj): SortedErrorObject[] => {\n    const SR_INDICATOR_PREFIX = process.env.NODE_ENV === 'production' || process.env.NODE_ENV === 'test' ? '' : '-sr'; // Useful for testing whether SR is reading out aria-live errors (sr) or aria-describedby ones\n\n    // Create array of error objects, sorted by layout\n    const sortedErrors: SortedErrorObject[] = Object.entries(errors).reduce((acc, [key, value]) => {\n        if (value) {\n            const errObj: ValidationRuleResult | SFError | GenericError = errors[key];\n\n            const TREAT_AS_SF_ERROR = 'errorI18n' in errObj && `rootNode` in errObj; // look for expected props, unique to an SFError\n\n            // Some ValidationRuleResults can be passed an object in the 'errorMessage' prop (to give country specific errors)\n            const ERROR_MSG_IS_OBJECT = typeof errObj.errorMessage === 'object';\n\n            /**\n             * Get error codes - these are used if we need to distinguish between showValidation & onBlur errors\n             * - For a ValidationRuleResult or GenericError the error \"code\" is contained in the errorMessage prop.\n             * - For an SFError the error \"code\" is contained in the error prop.\n             */\n            let errorCode: string;\n            if (TREAT_AS_SF_ERROR) {\n                errorCode = errObj.error;\n            } else {\n                /** Special handling for Address~postalCode (where the errorMessage is an object) */\n                if (ERROR_MSG_IS_OBJECT) {\n                    /** is ValidationRuleResult w. country specific error */\n                    errorCode = (errObj.errorMessage as ErrorMessageObject).translationKey;\n                } else {\n                    /** is ValidationRuleResult || GenericError || an as yet incorrectly formed error */\n                    errorCode = errObj.errorMessage as string;\n                }\n            }\n\n            /**\n             * Get corresponding error msg - a translated string we can place into the SRPanel\n             * NOTE: the error object for a secured field already contains the error in a translated form (errorI18n).\n             * For other fields we still need to translate it, so we use the errObj.errorMessage prop as a translation key\n             */\n            let errorMsg: string;\n            if (TREAT_AS_SF_ERROR && 'errorI18n' in errObj) {\n                errorMsg = errObj.errorI18n + SR_INDICATOR_PREFIX;\n            } else {\n                /**\n                 * For some fields, for a11y reasons (when the translated error msg doesn't contain a reference to the field it refers to), we need to\n                 * add the field type into the translated error message.\n                 *\n                 * This happens with generic errors\n                 *  e.g. \"field.error.required\": \"Enter the %{label}\"\n                 *   or \"invalid.format.expects\": \"%{label} Invalid format. Expected format: %{format}\"\n                 */\n                const mappedLabel = fieldTypeMappingFn ? fieldTypeMappingFn(key, i18n, countrySpecificLabels) : ''; // Retrieve the translated field name, if required\n\n                /** Special handling for Address~postalCode where the errorMessage object contains the details of the country specific format that should have been used for the postcode */\n                if (ERROR_MSG_IS_OBJECT) {\n                    /**  is ValidationRuleResult  w. country specific error */\n                    const translationKey = (errObj.errorMessage as ErrorMessageObject).translationKey;\n                    const countrySpecificFormat = (errObj.errorMessage as ErrorMessageObject).translationObject.values.format;\n\n                    errorMsg = `${i18n.get(translationKey, { values: { label: mappedLabel, format: countrySpecificFormat } })}${SR_INDICATOR_PREFIX}`;\n                } else {\n                    /** is ValidationRuleResult || GenericError || an as yet incorrectly formed error */\n                    errorMsg = i18n.get(errObj.errorMessage as string, { values: { label: mappedLabel } }) + SR_INDICATOR_PREFIX;\n                }\n            }\n\n            acc.push({ field: key, errorMessage: errorMsg, errorCode });\n\n            if (layout) acc.sort((a, b) => layout.indexOf(a.field) - layout.indexOf(b.field));\n        }\n        return acc;\n    }, []);\n\n    return sortedErrors;\n};\n\n/**\n * Implemented as a partial, with an object containing the first 6 arguments; then the final argument, errors, is passed to the partial\n *\n * NOTE: using this generic error setting fny is only suitable when errors for the SRPanel are *only* generated by showValidation().\n * When errors are also generated onBlur, as the user leaves the input, the SR message generation becomes more complex - see CardInput as an example\n */\nexport const setSRMessagesFromErrors = (\n    { i18n, fieldTypeMappingFn, SRPanelRef },\n    { errors, isValidating, layout, countrySpecificLabels }\n): SetSRMessagesReturnObject => {\n    const currentErrorsSortedByLayout = sortErrorsByLayout({\n        errors,\n        i18n,\n        fieldTypeMappingFn,\n        countrySpecificLabels,\n        layout\n    });\n\n    const doLog = false;\n\n    if (doLog) console.log('### setSRMessagesFromErrors::currentErrorsSortedByLayout:: ', currentErrorsSortedByLayout);\n\n    if (currentErrorsSortedByLayout.length) {\n        /** If validating i.e. \"on submit\" type event - then display all errors in the SR panel */\n        if (isValidating) {\n            const errorMsgArr: string[] = currentErrorsSortedByLayout.map(errObj => errObj.errorMessage);\n            if (doLog) console.log('### setSRMessagesFromErrors:: #1 multiple errors:: (validating) errorMsgArr=', errorMsgArr);\n            SRPanelRef.setMessages(errorMsgArr);\n\n            const fieldListArr: string[] = currentErrorsSortedByLayout.map(errObj => errObj.field);\n            return { currentErrorsSortedByLayout, action: ERROR_ACTION_FOCUS_FIELD, fieldToFocus: fieldListArr[0] };\n        } else {\n            // prettier-ignore\n            if (doLog) console.log('### setSRMessagesFromErrors:: #3 on blur scenario:: not validating but there might be an error, either to set or to clear');\n            SRPanelRef?.setMessages(null);\n\n            return { currentErrorsSortedByLayout, action: ERROR_ACTION_BLUR_SCENARIO }; // on blur scenario: not validating but there might be an error, either to set or to clear\n        }\n    } else {\n        if (doLog) console.log('### setSRMessagesFromErrors::componentDidUpdate:: #4 clearing errors:: NO currentErrorsSortedByLayout');\n        SRPanelRef?.setMessages(null); // no errors - so clear SR panel\n        return { currentErrorsSortedByLayout, action: 'none' };\n    }\n};\n\nexport const enhanceErrorObjectKeys = (errorObj, keyPrefix) => {\n    if (!errorObj) return null;\n    const enhancedObj = Object.entries(errorObj).reduce((acc, [key, value]) => {\n        if (value) {\n            const newKey = `${keyPrefix}${key}`;\n            acc[newKey] = value;\n        }\n        return acc;\n    }, {});\n\n    return enhancedObj;\n};\n"],"names":["getTranslatedErrors","i18n","errorCodeIdentifier","Object","values","SF_ErrorCodes","reduce","acc","value","includes","get","addErrorTranslationsToObject","originalObj","fieldType","nuObj","_object_spread","fieldTypeToErrorCodeIdentifier","error","getErrorMessageFromCode","errorCode","codeMap","errMsg","key","entries","toLowerCase","replace","ENCRYPTED_CARD_NUMBER","ErrorCodePrefixes","CC_NUM","ENCRYPTED_EXPIRY_DATE","CC_DAT","ENCRYPTED_EXPIRY_MONTH","CC_MTH","ENCRYPTED_EXPIRY_YEAR","CC_YR","ENCRYPTED_SECURITY_CODE","CC_CVC","ENCRYPTED_PWD_FIELD","KCP_PWD","sortErrorsByLayout","errors","layout","countrySpecificLabels","fieldTypeMappingFn","errObj","TREAT_AS_SF_ERROR","ERROR_MSG_IS_OBJECT","errorMessage","errorMsg","translationKey","errorI18n","mappedLabel","countrySpecificFormat","translationObject","format","label","push","field","sort","a","b","indexOf","setSRMessagesFromErrors","SRPanelRef","isValidating","currentErrorsSortedByLayout","length","errorMsgArr","map","setMessages","fieldListArr","action","ERROR_ACTION_FOCUS_FIELD","fieldToFocus","ERROR_ACTION_BLUR_SCENARIO","enhanceErrorObjectKeys","errorObj","keyPrefix"],"mappings":"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"}