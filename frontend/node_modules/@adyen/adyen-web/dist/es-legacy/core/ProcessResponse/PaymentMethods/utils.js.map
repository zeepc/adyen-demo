{"version":3,"file":"utils.js","sources":["../../../../../src/core/ProcessResponse/PaymentMethods/utils.ts"],"sourcesContent":["import { RawPaymentMethod, PaymentMethodsResponse, RawStoredPaymentMethod } from '../../../types/global-types';\nimport {\n    filterAllowedPaymentMethods,\n    filterEcomStoredPaymentMethods,\n    filterRemovedPaymentMethods,\n    filterSupportedStoredPaymentMethods\n} from './filters';\nimport uuidv4 from '../../../utils/uuid';\nimport type { PaymentMethod, StoredPaymentMethod } from './PaymentMethods';\n\n/**\n * Finds the fundingSource for a stored payment method by matching its brand\n * against the available payment methods.\n */\nfunction getFundingSourceForStoredCard(\n    storedPaymentMethod: RawStoredPaymentMethod,\n    paymentMethods: RawPaymentMethod[]\n): RawPaymentMethod['fundingSource'] {\n    if (storedPaymentMethod.type !== 'scheme') {\n        return undefined;\n    }\n\n    const storedBrand = storedPaymentMethod.brand;\n    if (!storedBrand) {\n        return undefined;\n    }\n\n    const matchingPaymentMethod = paymentMethods.find(pm => pm.type === 'scheme' && pm.brands?.includes(storedBrand));\n\n    return matchingPaymentMethod?.fundingSource;\n}\n\nconst processStoredPaymentMethod = (storedPM: RawStoredPaymentMethod, paymentMethods: RawPaymentMethod[]): StoredPaymentMethod => {\n    const fundingSource = getFundingSourceForStoredCard(storedPM, paymentMethods);\n    return {\n        ...storedPM,\n        storedPaymentMethodId: storedPM.id,\n        isStoredPaymentMethod: true,\n        ...(fundingSource && { fundingSource })\n    };\n};\n\n/**\n * Generate unique ID per payment method. Useful to fetch the correct payment method properties from the response\n * @param paymentMethod\n */\nfunction generatePaymentMethodId(paymentMethod: RawPaymentMethod): PaymentMethod {\n    return {\n        ...paymentMethod,\n        _id: uuidv4()\n    };\n}\n\nexport const processPaymentMethods = (\n    paymentMethods: RawPaymentMethod[],\n    { allowPaymentMethods = [], removePaymentMethods = [] }\n): PaymentMethod[] => {\n    if (!paymentMethods) return [];\n\n    return paymentMethods\n        .filter(filterAllowedPaymentMethods, allowPaymentMethods)\n        .filter(filterRemovedPaymentMethods, removePaymentMethods)\n        .map(generatePaymentMethodId);\n};\n\nexport const processStoredPaymentMethods = (\n    storedPaymentMethods: RawStoredPaymentMethod[],\n    { allowPaymentMethods = [], removePaymentMethods = [] },\n    paymentMethods: RawPaymentMethod[] = []\n): StoredPaymentMethod[] => {\n    if (!storedPaymentMethods) return [];\n\n    return storedPaymentMethods\n        .filter(filterSupportedStoredPaymentMethods) // only display supported stored payment methods\n        .filter(filterAllowedPaymentMethods, allowPaymentMethods)\n        .filter(filterRemovedPaymentMethods, removePaymentMethods)\n        .filter(filterEcomStoredPaymentMethods) // Only accept Ecommerce shopper interactions\n        .map(storedPM => processStoredPaymentMethod(storedPM, paymentMethods));\n};\n\nexport const checkPaymentMethodsResponse = (paymentMethodsResponse: PaymentMethodsResponse) => {\n    if (typeof paymentMethodsResponse === 'string') {\n        throw new Error(\n            'paymentMethodsResponse was provided but of an incorrect type (should be an object but a string was provided).' +\n                'Try JSON.parse(\"{...}\") your paymentMethodsResponse.'\n        );\n    }\n\n    if (paymentMethodsResponse instanceof Array) {\n        throw new Error(\n            'paymentMethodsResponse was provided but of an incorrect type (should be an object but an array was provided).' +\n                'Please check you are passing the whole response.'\n        );\n    }\n\n    if (paymentMethodsResponse && !paymentMethodsResponse?.paymentMethods?.length && !paymentMethodsResponse?.storedPaymentMethods?.length) {\n        console.warn('paymentMethodsResponse was provided but no payment methods were found.');\n    }\n};\n"],"names":["generatePaymentMethodId","paymentMethod","_object_spread_props","_object_spread","_id","uuidv4","processPaymentMethods","paymentMethods","allowPaymentMethods","removePaymentMethods","filter","filterAllowedPaymentMethods","filterRemovedPaymentMethods","map","processStoredPaymentMethods","storedPaymentMethods","filterSupportedStoredPaymentMethods","filterEcomStoredPaymentMethods","storedPM","fundingSource","storedPaymentMethod","type","storedBrand","brand","matchingPaymentMethod","find","pm","brands","includes","getFundingSourceForStoredCard","storedPaymentMethodId","id","isStoredPaymentMethod","processStoredPaymentMethod","checkPaymentMethodsResponse","paymentMethodsResponse","Error","Array","length","console","warn"],"mappings":"w/BA8CA,SAASA,EAAwBC,GAC7B,OAAOC,EAAAC,EAAA,CAAA,EACAF,GAAAA,CACHG,IAAKC,KAEb,CAEO,MAAMC,EAAwB,CACjCC,GACEC,sBAAsB,GAAIC,uBAAuB,MAE9CF,EAEEA,EACFG,OAAOC,EAA6BH,GACpCE,OAAOE,EAA6BH,GACpCI,IAAIb,GALmB,GAQnBc,EAA8B,CACvCC,GACEP,sBAAsB,GAAIC,uBAAuB,IACnDF,EAAqC,KAEhCQ,EAEEA,EACFL,OAAOM,GACPN,OAAOC,EAA6BH,GACpCE,OAAOE,EAA6BH,GACpCC,OAAOO,GACPJ,IAAIK,GA7CsB,EAACA,EAAkCX,KAClE,MAAMY,EAnBV,SACIC,EACAb,GAEA,GAAiC,WAA7Ba,EAAoBC,KACpB,OAGJ,MAAMC,EAAcF,EAAoBG,MACxC,IAAKD,EACD,OAGJ,MAAME,EAAwBjB,EAAekB,KAAKC,IAA8BA,IAAAA,QAAZ,WAAZA,EAAGL,OAA8B,QAATK,EAAAA,EAAGC,cAAHD,IAAAA,OAAAA,EAAAA,EAAWE,SAASN,MAEpG,OAAOE,aAAAA,EAAAA,EAAuBL,aAClC,CAG0BU,CAA8BX,EAAUX,GAC9D,OAAOJ,EAAAD,EAAAC,EAAA,CAAA,EACAe,GAAAA,CACHY,sBAAuBZ,EAASa,GAChCC,uBAAuB,IACnBb,GAAiB,CAAEA,mBAuCNc,CAA2Bf,EAAUX,IAPxB,GAUzB2B,EAA+BC,QAeTA,EAAmDA,EAdlF,GAAsC,iBAA3BA,EACP,MAAM,IAAIC,MACN,qKAKR,GAAID,aAAkCE,MAClC,MAAM,IAAID,MACN,kKAKJD,IAA2BA,SAAsC,QAAtCA,EAAAA,EAAwB5B,sBAAxB4B,IAAAA,SAAAA,EAAwCG,UAAWH,SAA4C,QAA5CA,EAAAA,EAAwBpB,4BAAxBoB,IAAAA,SAAAA,EAA8CG,SAC5HC,QAAQC,KAAK"}