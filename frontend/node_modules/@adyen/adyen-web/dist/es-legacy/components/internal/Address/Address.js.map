{"version":3,"file":"Address.js","sources":["../../../../../src/components/internal/Address/Address.tsx"],"sourcesContent":["import { Fragment, h } from 'preact';\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'preact/hooks';\nimport Fieldset from '../FormFields/Fieldset';\nimport ReadOnlyAddress from './components/ReadOnlyAddress';\nimport { getAddressValidationRules } from './validate';\nimport { addressFormatters, countrySpecificFormatters } from './validate.formats';\nimport { AddressProps } from './types';\nimport { AddressData } from '../../../types/global-types';\nimport FieldContainer from './components/FieldContainer';\nimport useForm from '../../../utils/useForm';\nimport Specifications from './Specifications';\nimport { ADDRESS_SCHEMA, FALLBACK_VALUE } from './constants';\nimport { getMaxLengthByFieldAndCountry } from '../../../utils/validator-utils';\nimport { useCoreContext } from '../../../core/Context/CoreProvider';\nimport AddressSearch from './components/AddressSearch';\nimport { ComponentMethodsRef } from '../UIElement/types';\nimport './Address.scss';\n\nexport default function Address(props: AddressProps) {\n    const { i18n } = useCoreContext();\n\n    const { label = '', requiredFields, visibility, iOSFocusedField = null, showContextualElement } = props;\n\n    /** An object by which to expose 'public' members to the parent UIElement */\n    const addressRef = useRef<ComponentMethodsRef>({});\n    // Just call once\n    if (!Object.keys(addressRef.current).length) {\n        props.setComponentRef?.(addressRef.current);\n    }\n\n    const specifications = useMemo(() => new Specifications(props.specifications), [props.specifications]);\n\n    const requiredFieldsSchema = specifications.getAddressSchemaForCountryFlat(props.countryCode).filter(field => requiredFields.includes(field));\n\n    const [hasSelectedAddress, setHasSelectedAddress] = useState(false);\n\n    const [useManualAddress, setUseManualAddress] = useState(false);\n\n    const [searchErrorMessage, setSearchErrorMessage] = useState('');\n\n    const showAddressSearch = !!props.onAddressLookup;\n\n    const [ignoreCountryChange, setIgnoreCountryChange] = useState(false);\n\n    const showAddressFields = props.onAddressLookup ? hasSelectedAddress || useManualAddress : true;\n\n    const { data, errors, valid, isValid, handleChangeFor, triggerValidation, setData, mergeData } = useForm<AddressData>({\n        schema: requiredFieldsSchema,\n        defaultData: props.data,\n        // Ensure any passed validation rules are merged with the default ones\n        rules: { ...getAddressValidationRules(specifications), ...props.validationRules },\n        formatters: addressFormatters\n    });\n\n    // In partial address mode, country is not in the form schema but we need it for regionalized labels.\n    // Store the merchant's country config once at mount, then use it if form data doesn't have country.\n    const initialCountryRef = useRef<string | undefined>((props.data as AddressData)?.country);\n    const effectiveCountry = (data.country || initialCountryRef.current)?.toUpperCase();\n    const dataWithCountry = useMemo(() => ({ ...data, country: effectiveCountry }), [data, effectiveCountry]);\n\n    const setSearchData = useCallback(\n        (selectedAddress: AddressData) => {\n            const propsKeysToProcess = ADDRESS_SCHEMA;\n            const newStateData = propsKeysToProcess.reduce((acc: AddressData, propKey) => {\n                // Make sure the data provided by the merchant is always strings\n                const providedValue = selectedAddress[propKey];\n                if (providedValue !== null && providedValue !== undefined) {\n                    // Cast everything to string\n                    acc[propKey] = String(providedValue);\n                }\n                return acc;\n            }, {});\n            mergeData(newStateData);\n            setIgnoreCountryChange(true);\n            triggerValidation();\n            setHasSelectedAddress(true);\n        },\n        [setHasSelectedAddress, triggerValidation, setData]\n    );\n\n    const onManualAddress = useCallback(() => {\n        setUseManualAddress(true);\n    }, []);\n\n    // Expose method expected by (parent) Address.tsx\n    addressRef.current.showValidation = () => {\n        triggerValidation();\n        if (showAddressSearch && !showAddressFields && !isValid) {\n            setSearchErrorMessage(i18n.get('address.errors.incomplete'));\n        } else {\n            setSearchErrorMessage('');\n        }\n    };\n\n    /**\n     * For iOS: iOSFocusedField is the name of the element calling for other elements to be disabled\n     * - so if it is set (meaning we are in iOS *and* an input has been focussed) only enable the field that corresponds to this element\n     */\n    const enabledFields: string[] = requiredFieldsSchema.filter(item => {\n        return !iOSFocusedField ? true : item === iOSFocusedField;\n    });\n\n    /**\n     * Effect that:\n     * - Resets validation for all fields by triggering handleChangeFor(fieldName, 'input')\n     * - Applies validation on postalCode field in case it has any value\n     */\n    useEffect((): void => {\n        // if the country was set via setSearchData we don't want to trigger this\n        if (ignoreCountryChange) {\n            setIgnoreCountryChange(false);\n            return;\n        }\n\n        const stateOrProvince = specifications.countryHasDataset(data.country) ? '' : FALLBACK_VALUE;\n        const newData = { ...data, stateOrProvince };\n\n        requiredFields.forEach(fieldName => {\n            handleChangeFor(fieldName, 'input')(newData[fieldName] ?? '');\n        });\n\n        if (newData.postalCode) {\n            handleChangeFor('postalCode', 'blur')(data.postalCode);\n        }\n    }, [data.country]);\n\n    /**\n     * Set the value of 'stateOrProvince' during the initial render if\n     * property is provided during the creation of the payment method\n     */\n    useEffect((): void => {\n        const stateFieldIsRequired = requiredFields.includes('stateOrProvince');\n        const countryHasStatesDataset = data.country && specifications.countryHasDataset(data.country);\n        const addressShouldHaveState = stateFieldIsRequired && countryHasStatesDataset;\n        const stateOrProvince = data.stateOrProvince || (addressShouldHaveState ? '' : FALLBACK_VALUE);\n\n        handleChangeFor('stateOrProvince', 'input')(stateOrProvince);\n    }, []);\n\n    useEffect((): void => {\n        const optionalFields = specifications.getOptionalFieldsForCountry(data.country);\n        const processedData = ADDRESS_SCHEMA.reduce((acc, cur) => {\n            const isOptional = optionalFields.includes(cur);\n            const isRequired = requiredFields.includes(cur);\n            const newValue = data[cur];\n            const initialValue = props.data[cur];\n            // recover default data values which are not requiredFields, or prefill with 'N/A'\n            const fallbackValue = !isRequired && !newValue && !!initialValue ? initialValue : FALLBACK_VALUE;\n            const value = (isOptional && !newValue) || !isRequired ? fallbackValue : newValue;\n            if (value?.length) acc[cur] = value;\n            return acc;\n        }, {});\n\n        // In partial address mode, ensure country is included in output for regionalized labels/validation.\n        if (!(processedData as AddressData).country && initialCountryRef.current) {\n            (processedData as AddressData).country = initialCountryRef.current;\n        }\n\n        props.onChange({ data: processedData, valid, errors, isValid });\n    }, [data, valid, errors, isValid]);\n\n    if (visibility === 'hidden') return null;\n    if (visibility === 'readOnly') return <ReadOnlyAddress data={data} label={label} />;\n\n    const getComponent = (fieldName: string, { classNameModifiers = [] }) => {\n        if (!requiredFields.includes(fieldName)) return null;\n\n        return (\n            <FieldContainer\n                key={fieldName}\n                allowedCountries={props.allowedCountries}\n                classNameModifiers={[...classNameModifiers, fieldName]}\n                data={dataWithCountry}\n                errors={errors}\n                valid={valid}\n                fieldName={fieldName}\n                onInput={handleChangeFor(fieldName, 'input')}\n                onBlur={handleChangeFor(fieldName, 'blur')}\n                onDropdownChange={handleChangeFor(fieldName, 'blur')}\n                specifications={specifications}\n                maxLength={getMaxLengthByFieldAndCountry(countrySpecificFormatters, fieldName, effectiveCountry, true)}\n                trimOnBlur={true}\n                disabled={!enabledFields.includes(fieldName)}\n                onFieldFocusAnalytics={props.onFieldFocusAnalytics}\n                onFieldBlurAnalytics={props.onFieldBlurAnalytics}\n            />\n        );\n    };\n\n    const getWrapper = group => (\n        <div className=\"adyen-checkout__field-group\">\n            {group.map(([field, size]) => getComponent(field, { classNameModifiers: [`col-${size}`] }))}\n        </div>\n    );\n\n    const addressSchema = specifications.getAddressSchemaForCountry(data.country);\n\n    return (\n        <Fragment>\n            <Fieldset classNameModifiers={[label, 'address']} label={label}>\n                {showAddressSearch && (\n                    <AddressSearch\n                        onAddressLookup={props.onAddressLookup}\n                        onAddressSelected={props.onAddressSelected}\n                        onSelect={setSearchData}\n                        onManualAddress={onManualAddress}\n                        externalErrorMessage={searchErrorMessage}\n                        hideManualButton={showAddressFields}\n                        showContextualElement={showContextualElement}\n                        contextualText={i18n.get('address.search.contextualText')}\n                        addressSearchDebounceMs={props.addressSearchDebounceMs}\n                    />\n                )}\n                {showAddressFields && (\n                    <Fragment>{addressSchema.map(field => (field instanceof Array ? getWrapper(field) : getComponent(field, {})))}</Fragment>\n                )}\n            </Fieldset>\n        </Fragment>\n    );\n}\n\nAddress.defaultProps = {\n    countryCode: null,\n    validationRules: null,\n    data: {},\n    onChange: () => {},\n    visibility: 'editable',\n    requiredFields: ADDRESS_SCHEMA,\n    specifications: {},\n    onFieldFocusAnalytics: () => {},\n    onFieldBlurAnalytics: () => {}\n};\n"],"names":["Address","props","data","i18n","useCoreContext","label","requiredFields","visibility","iOSFocusedField","showContextualElement","addressRef","useRef","Object","keys","current","length","setComponentRef","specifications","useMemo","Specifications","requiredFieldsSchema","getAddressSchemaForCountryFlat","countryCode","filter","field","includes","hasSelectedAddress","setHasSelectedAddress","useState","useManualAddress","setUseManualAddress","searchErrorMessage","setSearchErrorMessage","showAddressSearch","onAddressLookup","ignoreCountryChange","setIgnoreCountryChange","showAddressFields","errors","valid","isValid","handleChangeFor","triggerValidation","setData","mergeData","useForm","schema","defaultData","rules","_object_spread","getAddressValidationRules","validationRules","formatters","addressFormatters","initialCountryRef","_props_data","country","effectiveCountry","_this","toUpperCase","dataWithCountry","_object_spread_props","setSearchData","useCallback","selectedAddress","newStateData","ADDRESS_SCHEMA","reduce","acc","propKey","providedValue","String","onManualAddress","showValidation","get","enabledFields","item","useEffect","stateOrProvince","countryHasDataset","FALLBACK_VALUE","newData","forEach","fieldName","postalCode","stateFieldIsRequired","countryHasStatesDataset","addressShouldHaveState","optionalFields","getOptionalFieldsForCountry","processedData","cur","isOptional","isRequired","newValue","initialValue","value","onChange","h","ReadOnlyAddress","getComponent","classNameModifiers","FieldContainer","key","allowedCountries","onInput","onBlur","onDropdownChange","maxLength","getMaxLengthByFieldAndCountry","countrySpecificFormatters","trimOnBlur","disabled","onFieldFocusAnalytics","onFieldBlurAnalytics","addressSchema","getAddressSchemaForCountry","Fragment","Fieldset","AddressSearch","onAddressSelected","onSelect","externalErrorMessage","hideManualButton","contextualText","addressSearchDebounceMs","map","Array","div","className","size","defaultProps"],"mappings":"goDAkBe,SAASA,EAAQC,OAsC0BA,EAC5BC,EAtC1B,MAAMC,KAAEA,GAASC,KAEXC,MAAEA,EAAQ,GAAEC,eAAEA,EAAcC,WAAEA,EAAUC,gBAAEA,EAAkB,KAAIC,sBAAEA,GAA0BR,EAG5FS,EAAaC,EAA4B,IAG3CV,IAAAA,EADCW,OAAOC,KAAKH,EAAWI,SAASC,SACZ,QAArBd,EAAAA,EAAMe,2BAANf,GAAAA,EAAAA,KAAAA,EAAwBS,EAAWI,UAGvC,MAAMG,EAAiBC,EAAQ,IAAM,IAAIC,EAAelB,EAAMgB,gBAAiB,CAAChB,EAAMgB,iBAEhFG,EAAuBH,EAAeI,+BAA+BpB,EAAMqB,aAAaC,OAAOC,GAASlB,EAAemB,SAASD,KAE/HE,EAAoBC,GAAyBC,GAAS,IAEtDC,EAAkBC,GAAuBF,GAAS,IAElDG,EAAoBC,GAAyBJ,EAAS,IAEvDK,IAAsBhC,EAAMiC,iBAE3BC,EAAqBC,GAA0BR,GAAS,GAEzDS,GAAoBpC,EAAMiC,kBAAkBR,GAAsBG,IAElE3B,KAAEA,EAAIoC,OAAEA,EAAMC,MAAEA,EAAKC,QAAEA,EAAOC,gBAAEA,EAAeC,kBAAEA,EAAiBC,QAAEA,EAAOC,UAAEA,GAAcC,EAAqB,CAClHC,OAAQ1B,EACR2B,YAAa9C,EAAMC,KAEnB8C,MAAOC,EAAA,GAAKC,EAA0BjC,GAAoBhB,EAAMkD,iBAChEC,WAAYC,IAKVC,EAAoB3C,EAAsC,QAAVV,EAAAA,EAAMC,YAAND,IAAAA,SAADsD,EAA6BC,SAC5EC,GAA6D,QAAzCvD,EAAAA,EAAKsD,SAAWF,EAAkBxC,eAAlCZ,IAAAA,OAAAA,EAADwD,EAA6CC,cAChEC,GAAkB1C,EAAQ,IAAO2C,EAAAZ,EAAA,CAAA,EAAK/C,GAAAA,CAAMsD,QAASC,KAAqB,CAACvD,EAAMuD,KAEjFK,GAAgBC,EACjBC,IACG,MACMC,EADqBC,EACaC,OAAO,CAACC,EAAkBC,KAE9D,MAAMC,EAAgBN,EAAgBK,GAKtC,OAJIC,UAEAF,EAAIC,GAAWE,OAAOD,IAEnBF,GACR,CAAA,GACHxB,EAAUqB,GACV7B,GAAuB,GACvBM,IACAf,GAAsB,IAE1B,CAACA,EAAuBe,EAAmBC,IAGzC6B,GAAkBT,EAAY,KAChCjC,GAAoB,IACrB,IAGHpB,EAAWI,QAAQ2D,eAAiB,KAChC/B,IAIIV,GAHAC,GAAsBI,GAAsBG,EAGtB,GAFArC,EAAKuE,IAAI,+BAUvC,MAAMC,GAA0BvD,EAAqBG,OAAOqD,IAChDpE,GAAyBoE,IAASpE,GA8D9C,GAtDAqE,EAAU,KAEN,GAAI1C,EAEA,YADAC,GAAuB,GAI3B,MAAM0C,EAAkB7D,EAAe8D,kBAAkB7E,EAAKsD,SAAW,GAAKwB,EACxEC,EAAUpB,EAAAZ,EAAA,CAAA,EAAK/C,GAAAA,CAAM4E,oBAE3BxE,EAAe4E,QAAQC,IACiBF,IAAAA,EAApCxC,EAAgB0C,EAAW,QAA3B1C,CAAsD,QAAlBwC,EAAAA,EAAQE,cAARF,EAAAA,EAAsB,MAG1DA,EAAQG,YACR3C,EAAgB,aAAc,OAA9BA,CAAsCvC,EAAKkF,aAEhD,CAAClF,EAAKsD,UAMTqB,EAAU,KACN,MAAMQ,EAAuB/E,EAAemB,SAAS,mBAC/C6D,EAA0BpF,EAAKsD,SAAWvC,EAAe8D,kBAAkB7E,EAAKsD,SAChF+B,EAAyBF,GAAwBC,EACjDR,EAAkB5E,EAAK4E,kBAAoBS,EAAyB,GAAKP,GAE/EvC,EAAgB,kBAAmB,QAAnCA,CAA4CqC,IAC7C,IAEHD,EAAU,KACN,MAAMW,EAAiBvE,EAAewE,4BAA4BvF,EAAKsD,SACjEkC,EAAgBxB,EAAeC,OAAO,CAACC,EAAKuB,KAC9C,MAAMC,EAAaJ,EAAe/D,SAASkE,GACrCE,EAAavF,EAAemB,SAASkE,GACrCG,EAAW5F,EAAKyF,GAChBI,EAAe9F,EAAMC,KAAKyF,GAG1BK,EAAQJ,IAAgBE,IAAcD,EADrBA,GAAeC,IAAcC,EAA8Bf,EAAfe,EACMD,EAEzE,OADIE,eAAAA,EAAOjF,UAAQqD,EAAIuB,GAAOK,GACvB5B,GACR,CAAA,IAGEsB,EAA+BlC,SAAWF,EAAkBxC,UAC5D4E,EAA8BlC,QAAUF,EAAkBxC,SAG/Db,EAAMgG,SAAS,CAAE/F,KAAMwF,EAAenD,QAAOD,SAAQE,aACtD,CAACtC,EAAMqC,EAAOD,EAAQE,IAEN,WAAfjC,EAAyB,OAAO,KACpC,GAAmB,aAAfA,EAA2B,OAAO2F,EAACC,EAAAA,CAAgBjG,KAAMA,EAAMG,MAAOA,IAE1E,MAAM+F,GAAe,CAACjB,GAAqBkB,qBAAqB,MACvD/F,EAAemB,SAAS0D,GAGzBe,EAACI,EAAAA,CACGC,IAAKpB,EACLqB,iBAAkBvG,EAAMuG,iBACxBH,mBAAoB,IAAIA,EAAoBlB,GAC5CjF,KAAM0D,GACNtB,OAAQA,EACRC,MAAOA,EACP4C,UAAWA,EACXsB,QAAShE,EAAgB0C,EAAW,SACpCuB,OAAQjE,EAAgB0C,EAAW,QACnCwB,iBAAkBlE,EAAgB0C,EAAW,QAC7ClE,eAAgBA,EAChB2F,UAAWC,EAA8BC,EAA2B3B,EAAW1B,IAC/EsD,YAAY,EACZC,UAAWrC,GAAclD,SAAS0D,GAClC8B,sBAAuBhH,EAAMgH,sBAC7BC,qBAAsBjH,EAAMiH,uBAnBY,KA8B9CC,GAAgBlG,EAAemG,2BAA2BlH,EAAKsD,SAErE,OACI0C,EAACmB,OACGnB,EAACoB,EAAAA,CAASjB,mBAAoB,CAAChG,EAAO,WAAYA,MAAOA,GACpD4B,GACGiE,EAACqB,EAAAA,CACGrF,gBAAiBjC,EAAMiC,gBACvBsF,kBAAmBvH,EAAMuH,kBACzBC,SAAU3D,GACVU,gBAAiBA,GACjBkD,qBAAsB3F,EACtB4F,iBAAkBtF,EAClB5B,sBAAuBA,EACvBmH,eAAgBzH,EAAKuE,IAAI,iCACzBmD,wBAAyB5H,EAAM4H,0BAGtCxF,GACG6D,EAACmB,EAAAA,KAAUF,GAAcW,IAAItG,GAAUA,aAAiBuG,MAxBpE7B,EAAC8B,MAAAA,CAAIC,UAAU,+BAwBwEzG,EAvB5EsG,IAAI,EAAEtG,EAAO0G,KAAU9B,GAAa5E,EAAO,CAAE6E,mBAAoB,CAAC,OAAO6B,SAuBY9B,GAAa5E,EAAO,CAAA,MAK5H,CAEAxB,EAAQmI,aAAe,CACnB7G,YAAa,KACb6B,gBAAiB,KACjBjD,KAAM,CAAA,EACN+F,SAAU,OACV1F,WAAY,WACZD,eAAgB4D,EAChBjD,eAAgB,CAAA,EAChBgG,sBAAuB,OACvBC,qBAAsB"}