{"version":3,"file":"utils.js","sources":["../../../../../src/components/internal/OpenInvoice/utils.ts"],"sourcesContent":["import { OpenInvoiceActiveFieldsets, OpenInvoiceStateData, OpenInvoiceVisibility } from './types';\nimport Language from '../../../language';\nimport { mapFieldKey as mapFieldKeyAddress } from '../Address/utils';\nimport { StringObject } from '../Address/types';\n\nexport const fieldsetsSchema: Array<keyof OpenInvoiceStateData> = [\n    'companyDetails',\n    'personalDetails',\n    'billingAddress',\n    'deliveryAddress',\n    'bankAccount'\n];\n\nconst isPrefilled = (fieldsetData: object = {}): boolean => Object.keys(fieldsetData).length > 1;\n\nexport const getActiveFieldsData = (activeFieldsets: OpenInvoiceActiveFieldsets, data: OpenInvoiceStateData): OpenInvoiceStateData =>\n    Object.keys(data)\n        .filter(fieldset => activeFieldsets[fieldset])\n        .reduce((acc, cur) => {\n            acc[cur] = data[cur];\n            return acc;\n        }, {});\n\nexport const getInitialActiveFieldsets = (visibility: OpenInvoiceVisibility, data: OpenInvoiceStateData = {}): OpenInvoiceActiveFieldsets =>\n    fieldsetsSchema.reduce((acc, fieldset) => {\n        const isVisible = visibility[fieldset] !== 'hidden';\n        const isDeliveryAddress = fieldset === 'deliveryAddress';\n        const billingAddressIsHidden = visibility?.billingAddress === 'hidden';\n\n        // The delivery address will be active not only when set as visible\n        // but also when the billing address is hidden or when it has prefilled data\n        acc[fieldset] = isVisible && (!isDeliveryAddress || billingAddressIsHidden || isPrefilled(data[fieldset]));\n        return acc;\n    }, {} as OpenInvoiceActiveFieldsets);\n\n/**\n * Used by the SRPanel sorting function to tell it whether we need to add the field type to the SR panel message, and, if so, we retrieve the correct translation for the field type.\n * (Whether we need to add the field type depends on whether we know that the error message correctly reflects the label of the field. Ultimately all error messages should do this\n * and this mapping fn will become redundant)\n */\nexport const mapFieldKey = (key: string, i18n: Language, countrySpecificLabels: StringObject): string => {\n    let refKey = key;\n    let label;\n\n    // Differentiate between address types (billing and delivery)\n    const splitKey = refKey.split(':');\n    const hasSplitKey = splitKey.length > 1;\n\n    if (hasSplitKey) {\n        label = splitKey[0];\n        refKey = splitKey[1];\n    }\n\n    const addressKey = mapFieldKeyAddress(refKey, i18n, countrySpecificLabels);\n    // Also use the presence of a label to know that we are dealing with address related fields. (This matters now that addresses can contain first & last name fields.)\n    if (addressKey && label) return hasSplitKey ? `${i18n.get(label)} ${addressKey}` : addressKey;\n\n    switch (refKey) {\n        case 'dateOfBirth':\n        case 'shopperEmail':\n        case 'telephoneNumber':\n            return i18n.get(refKey);\n        default:\n            break;\n    }\n\n    // We know that the translated error messages do contain a reference to the field they refer to, so we won't need to map them\n    return null;\n};\n"],"names":["fieldsetsSchema","getActiveFieldsData","activeFieldsets","data","Object","keys","filter","fieldset","reduce","acc","cur","getInitialActiveFieldsets","visibility","isVisible","isDeliveryAddress","billingAddressIsHidden","billingAddress","fieldsetData","length","isPrefilled","mapFieldKey","key","i18n","countrySpecificLabels","label","refKey","splitKey","split","hasSplitKey","addressKey","mapFieldKeyAddress","get"],"mappings":"wDAKaA,EAAqD,CAC9D,iBACA,kBACA,iBACA,kBACA,eAKSC,EAAsB,CAACC,EAA6CC,IAC7EC,OAAOC,KAAKF,GACPG,OAAOC,GAAYL,EAAgBK,IACnCC,OAAO,CAACC,EAAKC,KACVD,EAAIC,GAAOP,EAAKO,GACTD,GACR,CAAA,GAEEE,EAA4B,CAACC,EAAmCT,EAA6B,CAAA,IACtGH,EAAgBQ,OAAO,CAACC,EAAKF,KACzB,MAAMM,EAAqC,WAAzBD,EAAWL,GACvBO,EAAiC,oBAAbP,EACpBQ,EAAwD,YAA/BH,aAAAA,EAAAA,EAAYI,gBAK3C,OADAP,EAAIF,GAAYM,KAAeC,GAAqBC,GAlBxC,EAACE,EAAuB,KAAgBb,OAAOC,KAAKY,GAAcC,OAAS,EAkBTC,CAAYhB,EAAKI,KACxFE,GACR,CAAA,GAOMW,EAAc,CAACC,EAAaC,EAAgBC,KACrD,IACIC,EADAC,EAASJ,EAIb,MAAMK,EAAWD,EAAOE,MAAM,KACxBC,EAAcF,EAASR,OAAS,EAElCU,IACAJ,EAAQE,EAAS,GACjBD,EAASC,EAAS,IAGtB,MAAMG,EAAaC,EAAmBL,EAAQH,EAAMC,GAEpD,GAAIM,GAAcL,EAAO,OAAOI,EAAc,GAAGN,EAAKS,IAAIP,MAAUK,IAAeA,EAEnF,OAAQJ,GACJ,IAAK,cACL,IAAK,eACL,IAAK,kBACD,OAAOH,EAAKS,IAAIN,GAMxB,OAAO"}