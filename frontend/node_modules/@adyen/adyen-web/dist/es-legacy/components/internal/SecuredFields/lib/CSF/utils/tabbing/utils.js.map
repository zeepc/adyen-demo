{"version":3,"file":"utils.js","sources":["../../../../../../../../../src/components/internal/SecuredFields/lib/CSF/utils/tabbing/utils.ts"],"sourcesContent":["import { selectOne, select } from '../../../utilities/dom';\n\nconst getPreviousTabbableEl = (matchEl, getPrevious = true) => {\n    const selStr =\n        '*[data-cse], a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), ' +\n        'button:not([disabled]), object, embed, *[tabindex], *[contenteditable]';\n    const allPotentialTabEls = Array.prototype.slice.call(select(document, selStr));\n    const actualTabEls = [];\n\n    allPotentialTabEls.forEach(potentialTabEl => {\n        const tabIndex = potentialTabEl.getAttribute('tabindex');\n        const isValidTabEl = !tabIndex || parseInt(tabIndex, 10) >= 0; // If tabindex hasn't been set, or is set and is >= 0\n        const bounds = potentialTabEl.getBoundingClientRect();\n        const hasDimensions = bounds.width > 0 && bounds.height > 0;\n\n        if (isValidTabEl && hasDimensions) {\n            actualTabEls.push(potentialTabEl);\n        }\n    });\n\n    // Loop through an array until it finds an element based on a test fn, and then return the elements index\n    const getIndexThruTest = (arr, testFn) => {\n        for (let n = 0; n < arr.length; n += 1) {\n            if (testFn(arr[n])) {\n                return n;\n            }\n        }\n        return -1;\n    };\n\n    // Test function\n    const isElOrContainsEl = tabEl => tabEl === matchEl || matchEl.contains(tabEl);\n\n    // Loop through the actualTabEls array until it finds the matchEl, returning its index\n    const matchElIndex = getIndexThruTest(actualTabEls, isElOrContainsEl);\n\n    // Are we actually getting the previous element OR the next?\n    const indexModifier = getPrevious ? -1 : 1;\n\n    return actualTabEls[matchElIndex + indexModifier];\n};\n\nexport const getPreviousTabbableNonSFElement = (passedFieldType, rootNode, getPrevious?) => {\n    // --\n    const sfEl = selectOne(rootNode, `[data-cse=${passedFieldType}]`);\n    return getPreviousTabbableEl(sfEl, getPrevious);\n};\n\nexport const focusExternalField = (pAdditionalField: HTMLElement): void => {\n    if (pAdditionalField) {\n        pAdditionalField.focus();\n\n        // Quirky! - Needed to work in the Components scenario\n        pAdditionalField.blur();\n        pAdditionalField.focus();\n    }\n};\n"],"names":["getPreviousTabbableNonSFElement","passedFieldType","rootNode","getPrevious","matchEl","allPotentialTabEls","Array","prototype","slice","call","select","document","actualTabEls","forEach","potentialTabEl","tabIndex","getAttribute","isValidTabEl","parseInt","bounds","getBoundingClientRect","hasDimensions","width","height","push","matchElIndex","arr","testFn","n","length","getIndexThruTest","tabEl","contains","getPreviousTabbableEl","selectOne","focusExternalField","pAdditionalField","focus","blur"],"mappings":"kEAEA,MAwCaA,EAAkC,CAACC,EAAiBC,EAAUC,IAxC7C,EAACC,EAASD,GAAc,KAClD,MAGME,EAAqBC,MAAMC,UAAUC,MAAMC,KAAKC,EAAOC,SAFzD,sLAGEC,EAAe,GAErBP,EAAmBQ,QAAQC,IACvB,MAAMC,EAAWD,EAAeE,aAAa,YACvCC,GAAgBF,GAAYG,SAASH,EAAU,KAAO,EACtDI,EAASL,EAAeM,wBACxBC,EAAgBF,EAAOG,MAAQ,GAAKH,EAAOI,OAAS,EAEtDN,GAAgBI,GAChBT,EAAaY,KAAKV,KAK1B,MAaMW,EAbmB,EAACC,EAAKC,KAC3B,IAAK,IAAIC,EAAI,EAAGA,EAAIF,EAAIG,OAAQD,GAAK,EACjC,GAAID,EAAOD,EAAIE,IACX,OAAOA,EAGf,OAAO,GAOUE,CAAiBlB,EAHbmB,GAASA,IAAU3B,GAAWA,EAAQ4B,SAASD,IAQxE,OAAOnB,EAAaa,GAFEtB,GAAc,EAAK,KAQlC8B,CADMC,EAAUhC,EAAU,aAAaD,MACXE,GAG1BgC,EAAsBC,IAC3BA,IACAA,EAAiBC,QAGjBD,EAAiBE,OACjBF,EAAiBC"}