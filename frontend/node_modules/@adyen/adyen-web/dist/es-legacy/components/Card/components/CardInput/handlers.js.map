{"version":3,"file":"handlers.js","sources":["../../../../../../src/components/Card/components/CardInput/handlers.ts"],"sourcesContent":["import { ENCRYPTED_CARD_NUMBER, CREDIT_CARD_SF_FIELDS } from '../../../internal/SecuredFields/lib/constants';\nimport { selectOne } from '../../../internal/SecuredFields/lib/utilities/dom';\nimport { CardFocusData } from '../../../internal/SecuredFields/lib/types';\nimport ua from '../../../internal/SecuredFields/lib/CSF/utils/userAgent';\nimport { windowScrollTo } from '../../../../utils/windowScrollTo';\nimport type { SecuredFieldsProviderRef } from '../../../internal/SecuredFields/SFP/types';\nimport { CardSetFormData, CardSetFormValid, CardSetFormErrors, OnFieldFocus } from './types';\nimport type { Dispatch, MutableRef, StateUpdater } from 'preact/hooks';\n\n/**\n * Helper for CardInput - gets a field name and sets focus on it\n */\nexport const setFocusOnFirstField = (isValidating: boolean, sfp: SecuredFieldsProviderRef, fieldToFocus: string) => {\n    if (isValidating) {\n        // Fix for iOS scrolling issues: can't programmatically set focus on a cross-origin element on iOS, so we scroll to it's label instead, so at least the element is in view\n        if (ua.__IS_IOS) {\n            const rootNode = sfp.current.getRootNode?.();\n            const elementToScrollTo: HTMLElement = rootNode?.querySelector(`[data-id=\"${fieldToFocus}\"]`);\n            windowScrollTo(elementToScrollTo);\n        }\n\n        // If not a cardInput related securedField - find field and set focus on it\n        if (!CREDIT_CARD_SF_FIELDS.includes(fieldToFocus)) {\n            setFocusOnNonSF(fieldToFocus, sfp, ua.__IS_IOS);\n        } else {\n            // Is a securedField - so it has its own focus procedures\n            sfp.current.setFocusOn(fieldToFocus);\n        }\n    }\n};\n\nexport const getAddressHandler = (setFormData: CardSetFormData, setFormValid: CardSetFormValid, setFormErrors: CardSetFormErrors) => {\n    // Return Handler fn:\n    return address => {\n        setFormData('billingAddress', address.data);\n        setFormValid('billingAddress', address.isValid);\n        setFormErrors('billingAddress', address.errors);\n    };\n};\n\nexport const getFocusHandler = (setFocusedElement: Dispatch<StateUpdater<string>>, onFocus: OnFieldFocus, onBlur: OnFieldFocus) => {\n    // Return Handler fn:\n    return (e: CardFocusData) => {\n        setFocusedElement(e.currentFocusObject);\n        e.focus === true ? onFocus(e.fieldType, e) : onBlur(e.fieldType, e);\n    };\n};\n\nexport const getAutoJumpHandler = (isAutoJumping: MutableRef<boolean>, sfp: SecuredFieldsProviderRef, layout: string[]) => {\n    return () => {\n        if (!isAutoJumping.current) {\n            isAutoJumping.current = true;\n\n            // CardInput can call this more than once in quick succession\n            // e.g. if field was in error (error + fieldValid) or other SFs are optional (fieldValid + allValid) etc\n            // - so make async to avoid double setFocus call\n            void Promise.resolve().then(() => {\n                const panIndex = layout.findIndex(elem => elem === ENCRYPTED_CARD_NUMBER);\n                const subsequentFields = layout.slice(panIndex + 1);\n\n                /**\n                 * Investigate subsequent fields to see if they can/should accept focus\n                 */\n                for (const field of subsequentFields) {\n                    // Is the next field a credit card related securedField?\n                    if (CREDIT_CARD_SF_FIELDS.includes(field)) {\n                        const isOptionalOrHidden = sfp.current.sfIsOptionalOrHidden(field);\n                        if (!isOptionalOrHidden) {\n                            sfp.current.setFocusOn(field);\n                            break;\n                        }\n                    } else {\n                        // If it isn't an SF - shift focus to it (we're currently not concerned with whether the field is optional)\n\n                        setFocusOnNonSF(field, sfp, false);\n                        break;\n                    }\n                }\n\n                isAutoJumping.current = false;\n            });\n        }\n    };\n};\n\nconst setFocusOnNonSF = (fieldName: string, sfp: SecuredFieldsProviderRef, shouldPreventScroll: boolean) => {\n    // We have an exception with the kcp taxNumber where the name of the field ('kcpTaxNumberOrDOB') doesn't match\n    // the value by which the field is referred to internally ('taxNumber')\n    if (fieldName === 'taxNumber') fieldName = 'kcpTaxNumberOrDOB';\n\n    const rootNode = sfp.current.getRootNode?.();\n\n    if (fieldName === 'country' || fieldName === 'stateOrProvince') {\n        // Set focus on dropdown\n        const field: HTMLElement = selectOne(rootNode, `.adyen-checkout__field--${fieldName} .adyen-checkout__filter-input`);\n        field?.focus({ preventScroll: shouldPreventScroll }); // Don't even attempt to allow the focus call to trigger a scroll on iOS\n    } else {\n        // Set focus on input\n        const field: HTMLElement = selectOne(rootNode, `[name=\"${fieldName}\"]`);\n        field?.focus({ preventScroll: shouldPreventScroll }); // Don't even attempt to allow the focus call to trigger a scroll on iOS\n    }\n};\n"],"names":["setFocusOnFirstField","isValidating","sfp","fieldToFocus","ua","__IS_IOS","rootNode","current","getRootNode","elementToScrollTo","querySelector","windowScrollTo","CREDIT_CARD_SF_FIELDS","includes","setFocusOn","setFocusOnNonSF","getAddressHandler","setFormData","setFormValid","setFormErrors","address","data","isValid","errors","getFocusHandler","setFocusedElement","onFocus","onBlur","e","currentFocusObject","focus","fieldType","getAutoJumpHandler","isAutoJumping","layout","Promise","resolve","then","panIndex","findIndex","elem","ENCRYPTED_CARD_NUMBER","subsequentFields","slice","field","sfIsOptionalOrHidden","fieldName","shouldPreventScroll","selectOne","preventScroll"],"mappings":"oVAYO,MAAMA,EAAuB,CAACC,EAAuBC,EAA+BC,KACvF,GAAIF,EAAc,CAEd,GAAIG,EAAGC,SAAU,KACIH,EAAAA,EAAjB,MAAMI,EAAkC,QAAvBJ,GAAAA,EAAAA,EAAIK,SAAQC,mBAAZN,IAAAA,OAAAA,EAAAA,EAAAA,KAAAA,GACXO,EAAiCH,aAAAA,EAAAA,EAAUI,cAAc,aAAaP,OAC5EQ,EAAeF,EACnB,CAGKG,EAAsBC,SAASV,GAIhCD,EAAIK,QAAQO,WAAWX,GAHvBY,EAAgBZ,EAAcD,EAAKE,EAAGC,SAK9C,GAGSW,EAAoB,CAACC,EAA8BC,EAAgCC,IAErFC,IACHH,EAAY,iBAAkBG,EAAQC,MACtCH,EAAa,iBAAkBE,EAAQE,SACvCH,EAAc,iBAAkBC,EAAQG,SAInCC,EAAkB,CAACC,EAAmDC,EAAuBC,IAE9FC,IACJH,EAAkBG,EAAEC,qBACR,IAAZD,EAAEE,MAAiBJ,EAAQE,EAAEG,UAAWH,GAAKD,EAAOC,EAAEG,UAAWH,IAI5DI,EAAqB,CAACC,EAAoC/B,EAA+BgC,IAC3F,KACED,EAAc1B,UACf0B,EAAc1B,SAAU,EAKnB4B,QAAQC,UAAUC,KAAK,KACxB,MAAMC,EAAWJ,EAAOK,UAAUC,GAAQA,IAASC,GAC7CC,EAAmBR,EAAOS,MAAML,EAAW,GAKjD,IAAK,MAAMM,KAASF,EAAkB,CAElC,IAAI9B,EAAsBC,SAAS+B,GAM5B,CAGH7B,EAAgB6B,EAAO1C,GAAK,GAC5B,KACJ,CATI,IAD2BA,EAAIK,QAAQsC,qBAAqBD,GACnC,CACrB1C,EAAIK,QAAQO,WAAW8B,GACvB,KACJ,CAOR,CAEAX,EAAc1B,SAAU,MAMlCQ,EAAkB,CAAC+B,EAAmB5C,EAA+B6C,SAKtD7C,EAAAA,EAFC,cAAd4C,IAA2BA,EAAY,qBAE3C,MAAMxC,EAAkC,QAAvBJ,GAAAA,EAAAA,EAAIK,SAAQC,mBAAZN,IAAAA,OAAAA,EAAAA,EAAAA,KAAAA,GAEjB,GAAkB,YAAd4C,GAAyC,oBAAdA,EAAiC,CAE5D,MAAMF,EAAqBI,EAAU1C,EAAU,2BAA2BwC,mCAC1EF,SAAAA,EAAOd,MAAM,CAAEmB,cAAeF,GAClC,KAAO,CAEH,MAAMH,EAAqBI,EAAU1C,EAAU,UAAUwC,OACzDF,SAAAA,EAAOd,MAAM,CAAEmB,cAAeF,GAClC"}