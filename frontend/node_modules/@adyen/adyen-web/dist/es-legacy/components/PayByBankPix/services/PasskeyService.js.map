{"version":3,"file":"PasskeyService.js","sources":["../../../../../src/components/PayByBankPix/services/PasskeyService.ts"],"sourcesContent":["import { PasskeySdkLoader } from './PasskeySdkLoader';\nimport {\n    PasskeyServiceConfig,\n    IPasskeyService,\n    IAdyenPasskey,\n    PasskeyErrorTypes,\n    RiskSignalsEnrollment,\n    RiskSignalsAuthentication,\n    NavigatorCredentialCreationsError,\n    NavigatorCredentialRetrievalError\n} from './types';\nimport AdyenCheckoutError, { SDK_ERROR } from '../../../core/Errors/AdyenCheckoutError';\nimport { DecodeObject } from '../../../types/global-types';\nimport base64 from '../../../utils/base64';\nimport type { IAnalytics } from '../../../core/Analytics/Analytics';\n\nexport class PasskeyService implements IPasskeyService {\n    private readonly passkeyServiceConfig: PasskeyServiceConfig;\n    private readonly analytics: IAnalytics;\n\n    private passkeySdk: IAdyenPasskey;\n    private riskSignals: RiskSignalsEnrollment | RiskSignalsAuthentication;\n    private initialized: Promise<void>;\n\n    constructor(configuration: PasskeyServiceConfig, analytics: IAnalytics) {\n        this.analytics = analytics;\n        this.passkeyServiceConfig = configuration;\n    }\n\n    get deviceId() {\n        return this.passkeyServiceConfig.deviceId;\n    }\n\n    public async getWebAuthnUnsupportedReason(): Promise<string> {\n        if (!window.PublicKeyCredential) {\n            return 'Browser does not support webauthn';\n        }\n        try {\n            const platformAuthenticatorAvailable = await window.PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n            if (!platformAuthenticatorAvailable) {\n                return 'Device does not have platform authenticator';\n            }\n        } catch (e) {\n            return 'Unknown error';\n        }\n\n        return '';\n    }\n\n    public initialize() {\n        if (this.initialized == null) {\n            this.initialized = new PasskeySdkLoader({ environment: this.passkeyServiceConfig.environment, analytics: this.analytics })\n                .load()\n                .then(passkey => {\n                    this.passkeySdk = passkey;\n                });\n        }\n\n        return this.initialized;\n    }\n\n    public async captureRiskSignalsEnrollment(): Promise<RiskSignalsEnrollment> {\n        await this.initialized;\n        if (this.riskSignals) {\n            // Cache it so we don't create unnecessary entries in the localstorage by calling captureRiskSignalsEnrollment\n            return this.riskSignals;\n        }\n\n        const result = await this.passkeySdk.captureRiskSignalsEnrollment(this.deviceId);\n        if (result && 'type' in result && result.type === PasskeyErrorTypes.RISK_SIGNALS_ERROR) {\n            throw new AdyenCheckoutError(SDK_ERROR, result.message);\n        }\n        this.riskSignals = result as RiskSignalsEnrollment;\n        return this.riskSignals;\n    }\n\n    public async canUseStoredCredential(): Promise<boolean> {\n        try {\n            await this.captureRiskSignalsAuthentication();\n            return true;\n        } catch (error) {\n            console.warn(\n                `The device is not eligible for stored credential authentication: ${error instanceof Error ? error?.message : 'unknown error'}`\n            );\n            return false;\n        }\n    }\n\n    public async captureRiskSignalsAuthentication(): Promise<RiskSignalsAuthentication> {\n        await this.initialized;\n        const result = await this.passkeySdk.captureRiskSignalsAuthentication(this.deviceId);\n        if (result && 'type' in result && result.type === PasskeyErrorTypes.RISK_SIGNALS_ERROR) {\n            throw new AdyenCheckoutError(SDK_ERROR, result.message);\n        }\n        return result as RiskSignalsAuthentication;\n    }\n\n    public async createCredentialForEnrollment(registrationOptions: string): Promise<string> {\n        await this.initialized;\n        const options = this.decodeJsonBase64(registrationOptions, 'Failed to decode registrationOptions');\n        const result = await this.passkeySdk.createCredentialForEnrollment(options);\n        if (result && 'type' in result && result.type === PasskeyErrorTypes.CREDENTIAL_CREATION_ERROR) {\n            throw new AdyenCheckoutError(SDK_ERROR, (result as NavigatorCredentialCreationsError).message);\n        }\n        return base64.encode(JSON.stringify(result));\n    }\n\n    public async authenticateWithCredential(authenticationOptions: string): Promise<string> {\n        await this.initialized;\n        const options = this.decodeJsonBase64(authenticationOptions, 'Failed to decode authenticationOptions');\n        const result = await this.passkeySdk.authenticateWithCredential(options);\n        if (result && 'type' in result && result.type === PasskeyErrorTypes.CREDENTIAL_RETRIEVAL_ERROR) {\n            throw new AdyenCheckoutError(SDK_ERROR, (result as NavigatorCredentialRetrievalError).message);\n        }\n        return base64.encode(JSON.stringify(result));\n    }\n\n    private decodeJsonBase64(encoded: string, errorMessage: string) {\n        const decoded: DecodeObject = base64.decode(encoded);\n        if (!decoded.success) {\n            throw new AdyenCheckoutError(SDK_ERROR, errorMessage);\n        }\n        return JSON.parse(decoded.data);\n    }\n}\n"],"names":["PasskeyService","deviceId","this","passkeyServiceConfig","getWebAuthnUnsupportedReason","window","PublicKeyCredential","isUserVerifyingPlatformAuthenticatorAvailable","e","initialize","initialized","PasskeySdkLoader","environment","analytics","load","then","passkey","passkeySdk","captureRiskSignalsEnrollment","riskSignals","result","type","PasskeyErrorTypes","RISK_SIGNALS_ERROR","AdyenCheckoutError","SDK_ERROR","message","canUseStoredCredential","captureRiskSignalsAuthentication","error","console","warn","Error","createCredentialForEnrollment","registrationOptions","options","decodeJsonBase64","CREDENTIAL_CREATION_ERROR","base64","encode","JSON","stringify","authenticateWithCredential","authenticationOptions","CREDENTIAL_RETRIEVAL_ERROR","encoded","errorMessage","decoded","decode","success","parse","data","constructor","configuration","_define_property"],"mappings":"kVAgBO,MAAMA,EAaT,YAAIC,GACA,OAAOC,KAAKC,qBAAqBF,QACrC,CAEA,kCAAaG,GACT,IAAKC,OAAOC,oBACR,MAAO,oCAEX,IAEI,UAD6CD,OAAOC,oBAAoBC,gDAEpE,MAAO,6CAEf,CAAE,MAAOC,GACL,MAAO,eACX,CAEA,MAAO,EACX,CAEOC,UAAAA,GASH,OARwB,MAApBP,KAAKQ,cACLR,KAAKQ,YAAc,IAAIC,EAAiB,CAAEC,YAAaV,KAAKC,qBAAqBS,YAAaC,UAAWX,KAAKW,YACzGC,OACAC,KAAKC,IACFd,KAAKe,WAAaD,KAIvBd,KAAKQ,WAChB,CAEA,kCAAaQ,GAET,SADMhB,KAAKQ,YACPR,KAAKiB,YAEL,OAAOjB,KAAKiB,YAGhB,MAAMC,QAAelB,KAAKe,WAAWC,6BAA6BhB,KAAKD,UACvE,GAAImB,GAAU,SAAUA,GAAUA,EAAOC,OAASC,EAAkBC,mBAChE,MAAM,IAAIC,EAAmBC,EAAWL,EAAOM,SAGnD,OADAxB,KAAKiB,YAAcC,EACZlB,KAAKiB,WAChB,CAEA,4BAAaQ,GACT,IAEI,aADMzB,KAAK0B,oCACJ,CACX,CAAE,MAAOC,GAIL,OAHAC,QAAQC,KACJ,oEAAoEF,aAAiBG,MAAQH,aAAAA,EAAAA,EAAOH,QAAU,oBAE3G,CACX,CACJ,CAEA,sCAAaE,SACH1B,KAAKQ,YACX,MAAMU,QAAelB,KAAKe,WAAWW,iCAAiC1B,KAAKD,UAC3E,GAAImB,GAAU,SAAUA,GAAUA,EAAOC,OAASC,EAAkBC,mBAChE,MAAM,IAAIC,EAAmBC,EAAWL,EAAOM,SAEnD,OAAON,CACX,CAEA,mCAAaa,CAA8BC,SACjChC,KAAKQ,YACX,MAAMyB,EAAUjC,KAAKkC,iBAAiBF,EAAqB,wCACrDd,QAAelB,KAAKe,WAAWgB,8BAA8BE,GACnE,GAAIf,GAAU,SAAUA,GAAUA,EAAOC,OAASC,EAAkBe,0BAChE,MAAM,IAAIb,EAAmBC,EAAYL,EAA6CM,SAE1F,OAAOY,EAAOC,OAAOC,KAAKC,UAAUrB,GACxC,CAEA,gCAAasB,CAA2BC,SAC9BzC,KAAKQ,YACX,MAAMyB,EAAUjC,KAAKkC,iBAAiBO,EAAuB,0CACvDvB,QAAelB,KAAKe,WAAWyB,2BAA2BP,GAChE,GAAIf,GAAU,SAAUA,GAAUA,EAAOC,OAASC,EAAkBsB,2BAChE,MAAM,IAAIpB,EAAmBC,EAAYL,EAA6CM,SAE1F,OAAOY,EAAOC,OAAOC,KAAKC,UAAUrB,GACxC,CAEQgB,gBAAAA,CAAiBS,EAAiBC,GACtC,MAAMC,EAAwBT,EAAOU,OAAOH,GAC5C,IAAKE,EAAQE,QACT,MAAM,IAAIzB,EAAmBC,EAAWqB,GAE5C,OAAON,KAAKU,MAAMH,EAAQI,KAC9B,CAnGA,WAAAC,CAAYC,EAAqCxC,GAPjDyC,EAAApD,KAAiBC,+BACjBmD,EAAApD,KAAiBW,oBAEjByC,EAAApD,KAAQe,qBACRqC,EAAApD,KAAQiB,sBACRmC,EAAApD,KAAQQ,sBAGJR,KAAKW,UAAYA,EACjBX,KAAKC,qBAAuBkD,CAChC"}