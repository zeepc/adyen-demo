{"version":3,"file":"useForm.js","sources":["../../../../src/utils/useForm/useForm.ts"],"sourcesContent":["import { useCallback, useEffect, useMemo, useReducer } from 'preact/hooks';\nimport Validator from '../Validator';\nimport { getReducer, init } from './reducer';\nimport { Form, FormState, FormProps, Formatter } from './types';\n\nfunction isFormatterObject(formatter: Formatter | Function): formatter is Formatter {\n    return formatter && 'formatterFn' in formatter;\n}\n\nfunction useForm<FormSchema>(props: FormProps): Form<FormSchema> {\n    const { rules = {}, formatters = {}, defaultData = {}, fieldProblems = {}, schema = [] } = props;\n\n    const validator = useMemo(() => new Validator(rules), [rules]);\n\n    /** Formats and validates a field */\n    const processField = ({ key, value, mode }, fieldContext) => {\n        // Find a formatting function either stored under 'key' or a level deeper under a 'formatter' property\n        const formatter = formatters?.[key];\n        const formatterFn = isFormatterObject(formatter) ? formatter.formatterFn : formatter;\n        const formattedValue = formatterFn && typeof formatterFn === 'function' ? formatterFn(value ?? '', fieldContext) : value;\n\n        const validationResult = validator.validate({ key, value: formattedValue, mode }, fieldContext);\n        return [formattedValue, validationResult];\n    };\n\n    const [state, dispatch] = useReducer<FormState<FormSchema>, any, any>(\n        getReducer(processField),\n        { defaultData, schema: schema ?? [], processField, fieldProblems },\n        init\n    );\n    const isValid = useMemo(() => state.schema.reduce((acc, val) => acc && state.valid[val], true), [state.schema, state.valid]);\n\n    const getTargetValue = (key, e) => {\n        if (!e.target) return e;\n\n        if (e.target.type === 'checkbox') {\n            return !state.data[key];\n        }\n        return e.target.value;\n    };\n\n    /** Formats, validates, and stores a new value for a form field */\n    const handleChangeFor = (key, mode) => {\n        return e => {\n            const value = getTargetValue(key, e);\n            dispatch({ type: 'updateField', key, value, mode });\n        };\n    };\n\n    /** Validates every field in the form OR just those in selectedSchema */\n    const triggerValidation = useCallback((selectedSchema = null) => {\n        dispatch({ type: 'validateForm', selectedSchema });\n    }, []);\n\n    const setErrors = useCallback((key, value) => dispatch({ type: 'setErrors', key, value }), []);\n    const setValid = useCallback((key, value) => dispatch({ type: 'setValid', key, value }), []);\n    const setData = useCallback((key, value) => dispatch({ type: 'setData', key, value }), []);\n    const mergeData = useCallback(data => dispatch({ type: 'mergeData', data }), []);\n    const setSchema = useCallback(schema => dispatch({ type: 'setSchema', schema, defaultData }), [state.schema]);\n    const mergeForm = useCallback(formValue => dispatch({ type: 'mergeForm', formValue }), []);\n    const setFieldProblems = useCallback(fieldProblems => dispatch({ type: 'setFieldProblems', fieldProblems }), [state.schema]);\n\n    // Set reducer fields problems if fieldProblems prop changes\n    useEffect(() => {\n        setFieldProblems(fieldProblems ?? {});\n    }, [JSON.stringify(fieldProblems)]);\n\n    return {\n        handleChangeFor,\n        triggerValidation,\n        setSchema,\n        setData,\n        mergeData,\n        setValid,\n        setErrors,\n        isValid,\n        mergeForm,\n        setFieldProblems,\n        schema: state.schema,\n        valid: state.valid,\n        errors: state.errors,\n        data: state.data,\n        fieldProblems: state.fieldProblems\n    };\n}\n\nexport default useForm;\n"],"names":["useForm","props","rules","formatters","defaultData","fieldProblems","schema","validator","useMemo","Validator","processField","key","value","mode","fieldContext","formatter","formatterFn","isFormatterObject","formattedValue","validate","state","dispatch","useReducer","getReducer","init","isValid","reduce","acc","val","valid","triggerValidation","useCallback","selectedSchema","type","setErrors","setValid","setData","mergeData","data","setSchema","mergeForm","formValue","setFieldProblems","useEffect","JSON","stringify","handleChangeFor","e","target","getTargetValue","errors"],"mappings":"iNASA,SAASA,EAAoBC,GACzB,MAAMC,MAAEA,EAAQ,GAAEC,WAAEA,EAAa,CAAA,EAAEC,YAAEA,EAAc,CAAA,EAAEC,cAAEA,EAAgB,CAAA,EAAEC,OAAEA,EAAS,IAAOL,EAErFM,EAAYC,EAAQ,IAAM,IAAIC,EAAUP,GAAQ,CAACA,IAGjDQ,EAAe,EAAGC,MAAKC,QAAOC,QAAQC,KAExC,MAAMC,EAAYZ,aAAAA,EAAAA,EAAaQ,GACzBK,EAbd,SAA2BD,GACvB,OAAOA,GAAa,gBAAiBA,CACzC,CAW4BE,CAAkBF,GAAaA,EAAUC,YAAcD,EACrEG,EAAiBF,GAAsC,mBAAhBA,EAA6BA,EAAYJ,QAAAA,EAAS,GAAIE,GAAgBF,EAGnH,MAAO,CAACM,EADiBX,EAAUY,SAAS,CAAER,MAAKC,MAAOM,EAAgBL,QAAQC,MAI/EM,EAAOC,GAAYC,EACtBC,EAAWb,GACX,CAAEN,cAAaE,OAAQA,QAAAA,EAAU,GAAII,eAAcL,iBACnDmB,GAEEC,EAAUjB,EAAQ,IAAMY,EAAMd,OAAOoB,OAAO,CAACC,EAAKC,IAAQD,GAAOP,EAAMS,MAAMD,IAAM,GAAO,CAACR,EAAMd,OAAQc,EAAMS,QAoB/GC,EAAoBC,EAAY,CAACC,EAAiB,QACpDX,EAAS,CAAEY,KAAM,eAAgBD,oBAClC,IAEGE,EAAYH,EAAY,CAACpB,EAAKC,IAAUS,EAAS,CAAEY,KAAM,YAAatB,MAAKC,UAAU,IACrFuB,EAAWJ,EAAY,CAACpB,EAAKC,IAAUS,EAAS,CAAEY,KAAM,WAAYtB,MAAKC,UAAU,IACnFwB,EAAUL,EAAY,CAACpB,EAAKC,IAAUS,EAAS,CAAEY,KAAM,UAAWtB,MAAKC,UAAU,IACjFyB,EAAYN,EAAYO,GAAQjB,EAAS,CAAEY,KAAM,YAAaK,SAAS,IACvEC,EAAYR,EAAYzB,GAAUe,EAAS,CAAEY,KAAM,YAAa3B,SAAQF,gBAAgB,CAACgB,EAAMd,SAC/FkC,EAAYT,EAAYU,GAAapB,EAAS,CAAEY,KAAM,YAAaQ,cAAc,IACjFC,EAAmBX,EAAY1B,GAAiBgB,EAAS,CAAEY,KAAM,mBAAoB5B,kBAAkB,CAACe,EAAMd,SAOpH,OAJAqC,EAAU,KACND,EAAiBrC,QAAAA,EAAiB,KACnC,CAACuC,KAAKC,UAAUxC,KAEZ,CACHyC,gBA1BoB,CAACnC,EAAKE,IACnBkC,IACH,MAAMnC,EAZS,EAACD,EAAKoC,IACpBA,EAAEC,OAEe,aAAlBD,EAAEC,OAAOf,MACDb,EAAMkB,KAAK3B,GAEhBoC,EAAEC,OAAOpC,MALMmC,EAWJE,CAAetC,EAAKoC,GAClC1B,EAAS,CAAEY,KAAM,cAAetB,MAAKC,QAAOC,UAwBhDiB,oBACAS,YACAH,UACAC,YACAF,WACAD,YACAT,UACAe,YACAE,mBACApC,OAAQc,EAAMd,OACduB,MAAOT,EAAMS,MACbqB,OAAQ9B,EAAM8B,OACdZ,KAAMlB,EAAMkB,KACZjC,cAAee,EAAMf,cAE7B"}